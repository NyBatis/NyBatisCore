package org.nybatis.core.file;import org.nybatis.core.conf.Const;import org.nybatis.core.exception.unchecked.ClassNotExistException;import org.nybatis.core.exception.unchecked.UncheckedIOException;import org.nybatis.core.file.handler.FileFinder;import org.nybatis.core.file.handler.ZipFileHandler;import org.nybatis.core.model.NList;import org.nybatis.core.util.ClassUtil;import org.nybatis.core.util.StringUtil;import org.nybatis.core.worker.WorkerReadLine;import org.nybatis.core.worker.WorkerWriteBuffer;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.ObjectInput;import java.io.ObjectInputStream;import java.io.ObjectOutput;import java.io.ObjectOutputStream;import java.io.OutputStream;import java.io.OutputStreamWriter;import java.nio.charset.Charset;import java.nio.charset.StandardCharsets;import java.nio.file.CopyOption;import java.nio.file.FileSystems;import java.nio.file.FileVisitOption;import java.nio.file.FileVisitResult;import java.nio.file.Files;import java.nio.file.InvalidPathException;import java.nio.file.Path;import java.nio.file.PathMatcher;import java.nio.file.Paths;import java.nio.file.SimpleFileVisitor;import java.nio.file.StandardCopyOption;import java.nio.file.attribute.BasicFileAttributes;import java.util.ArrayList;import java.util.Arrays;import java.util.EnumSet;import java.util.HashSet;import java.util.List;import java.util.Set;import java.util.zip.GZIPInputStream;import java.util.zip.GZIPOutputStream;/** * File Utility * * @author nayasis@gmail.com * */public class FileUtil {    private static final String UTF_8 = StandardCharsets.UTF_8.toString();    /**     * Delete file or directory     *     * @param filePath  file path or directory path     * @throws UncheckedIOException  if an I/O error occurs     */	public static void delete( Path filePath ) throws UncheckedIOException {		if( filePath == null || notExists( filePath ) ) return;		try {            if( isDirectory(filePath) ) {                Files.walkFileTree( filePath, new SimpleFileVisitor<Path>() {                    @Override                    public FileVisitResult visitFile( Path file, BasicFileAttributes attributes ) throws IOException {                        Files.delete(file);                        return FileVisitResult.CONTINUE;                    }                    @Override                    public FileVisitResult visitFileFailed( Path file, IOException e ) throws IOException {                        Files.delete(file);                        return FileVisitResult.CONTINUE;                    }                    @Override                    public FileVisitResult postVisitDirectory( Path dir, IOException e ) throws IOException {                        if ( e != null) throw e;                        Files.delete( dir );                        return FileVisitResult.CONTINUE;                    }                });            } else {                Files.delete( filePath );            }        } catch( IOException e ) {        	throw new UncheckedIOException( e );        }	}    /**     * Delete file or directory     *     * @param filePath  file path or directory path     * @throws UncheckedIOException  if an I/O error occurs     */    public static void delete( String filePath ) throws UncheckedIOException {        if( filePath == null || notExists( filePath ) ) return;    	delete( new File(filePath) );    }    /**     * Delete file or directory     *     * @param file  file or directory     * @throws UncheckedIOException  if an I/O error occurs     */    public static void delete( File file ) throws UncheckedIOException {        if( file != null && file.exists() ) {            delete( file.toPath() );        }    }    /**     * Get file extention     *     * @param filePath  file name or full path     * @return file extension     */    public static String getExtention( String filePath ) {        if( filePath == null ) return "";        int index = filePath.lastIndexOf( '.' );        if( index < 0 ) return "";        String ext = filePath.substring( index + 1 );        if( ext.contains( File.pathSeparator ) ) return "";        return ext;    }    /**     * Get file extention     *     * @param file  file     * @return file extension     */    public static String getExtention( File file ) {    	return ( file == null ) ? "" : getExtention( file.getName() );    }    /**     * Get file extention     *     * @param path  path     * @return file extension     */    public static String getExtention( Path path ) {        return ( path == null ) ? "" : getExtention( path.getFileName().toString() );    }    /**     * nomalize file separator to "/" and remove last "/" seperator.     *     * <pre>     *     *     On windows, path is used like below.     *      "c:\\document\\desktop\\tmp"     *     *     this method nomalize file seperator to "/" simply.     *     *     ex.     *     *       FileUtil.nomalizeSeparator( "c:\\document/a/b\\c" );     *         → "c:/document/a/b/c"     *     * </pre>     *     * @param filePath  file path     * @return file path having "/" separator only.     */    public static String nomalizeSeparator( String filePath ) {        String path = StringUtil.nvl( filePath ).trim();        if( "\\".equals( File.separator ) ) {            path = path.replaceAll( "\\\\", "/" );        }        return path.replaceAll( "/+", "/" ).replaceFirst( "(.*)/$", "$1" );    }    /**     * nomalize file separator to "/" and remove last "/" seperator.     *     * <pre>     *     *     On windows, path is used like below.     *      "c:\\document\\desktop\\tmp"     *     *     this method nomalize file seperator to "/" simply.     *     *     ex.     *     *       FileUtil.nomalizeSeparator( "c:\\document/a/b\\c" );     *         → "c:/document/a/b/c"     *     * </pre>     *     * @param filePath  file path     * @return file path having "/" separator only.     */    public static String nomalizeSeparator( Path filePath ) {        return filePath == null ? "" : nomalizeSeparator( filePath.toString() );    }    /**     * convert patterns to glob PathMatcher     *     * @param patterns patterns     * @return glob PathMatcher     */    public static Set<PathMatcher> toPathMacher( String... patterns ) {        Set<PathMatcher> matchers = new HashSet<>();        for( String pattern : new HashSet<>( Arrays.asList( patterns )) ) {            if( StringUtil.isEmpty( pattern ) ) continue;            if( ! pattern.contains("/") && ! pattern.contains("\\") ) {                pattern = "**/" + pattern;            }            matchers.add( FileSystems.getDefault().getPathMatcher( "glob:" + pattern ) );        }        return matchers;    }    /**     * Search list of files or directories in sub directory.     *     *     * @param searchDir         root directory to search     * @param includeFile       include file     * @param includeDirectory  include directory     * @param scanDepth         depth to scan     * <pre>     *   -1 : infinite     *    0 : in searchDir itself     *    1 : from searchDir to 1 depth sub directory     *    2 : from searchDir to 2 depth sub directory     *    ...     * </pre>     * @param matchingPattern   path matching pattern (glob expression. if not exists, add all result)     * <pre>     * ** : ignore directory variation     * *  : filename LIKE search     *     * 1. **.xml           : all files having "xml" extension below searchDir and it's all sub directories.     * 2. *.xml            : all files having "xml" extension in searchDir     * 3. c:\home\*\*.xml  : all files having "xml" extension below 'c:\home\' and it's just 1 depth below directories.     * 4. c:\home\**\*.xml : all files having "xml" extension below 'c:\home\' and it's all sub directories.     *     * 1. *  It matches zero , one or more than one characters. While matching, it will not cross directories boundaries.     * 2. ** It does the same as * but it crosses the directory boundaries.     * 3. ?  It matches only one character for the given name.     * 4. \  It helps to avoid characters to be interpreted as special characters.     * 5. [] In a set of characters, only single character is matched. If (-) hyphen is used then, it matches a range of characters. Example: [efg] matches "e","f" or "g" . [a-d] matches a range from a to d.     * 6. {} It helps to matches the group of sub patterns.     *     * 1. *.java when given path is java , we will get true by PathMatcher.matches(path).     * 2. *.* if file contains a dot, pattern will be matched.     * 3. *.{java,txt} If file is either java or txt, path will be matched.     * 4. abc.? matches a file which start with abc and it has extension with only single character.     *     * </pre>     *     * @return list of files or directories     * @throws UncheckedIOException  if an I/O error occurs     */    public static List<Path> search( String searchDir, boolean includeFile, boolean includeDirectory, int scanDepth, String... matchingPattern ) {        if( StringUtil.isEmpty( searchDir ) ) return new ArrayList<>();        return search( Paths.get( searchDir ), includeFile, includeDirectory, scanDepth, matchingPattern ) ;    }    /**     * Search list of files or directories in sub directory.     *     *     * @param searchDir         root directory to search     * @param includeFile       include file     * @param includeDirectory  include directory     * @param scanDepth         depth to scan     * <pre>     *   -1 : infinite     *    0 : in searchDir itself     *    1 : from searchDir to 1 depth sub directory     *    2 : from searchDir to 2 depth sub directory     *    ...     * </pre>     * @param matchingPattern   path matching pattern (glob expression. if not exists, add all result)     * <pre>     * ** : ignore directory variation     * *  : filename LIKE search     *     * 1. **.xml           : all files having "xml" extension below searchDir and it's all sub directories.     * 2. *.xml            : all files having "xml" extension in searchDir     * 3. c:\home\*\*.xml  : all files having "xml" extension below 'c:\home\' and it's just 1 depth below directories.     * 4. c:\home\**\*.xml : all files having "xml" extension below 'c:\home\' and it's all sub directories.     *     * 1. *  It matches zero , one or more than one characters. While matching, it will not cross directories boundaries.     * 2. ** It does the same as * but it crosses the directory boundaries.     * 3. ?  It matches only one character for the given name.     * 4. \  It helps to avoid characters to be interpreted as special characters.     * 5. [] In a set of characters, only single character is matched. If (-) hyphen is used then, it matches a range of characters. Example: [efg] matches "e","f" or "g" . [a-d] matches a range from a to d.     * 6. {} It helps to matches the group of sub patterns.     *     * 1. *.java when given path is java , we will get true by PathMatcher.matches(path).     * 2. *.* if file contains a dot, pattern will be matched.     * 3. *.{java,txt} If file is either java or txt, path will be matched.     * 4. abc.? matches a file which start with abc and it has extension with only single character.     * </pre>     *     * @return list of files or directories     * @throws UncheckedIOException  if an I/O error occurs     */    public static List<Path> search( Path searchDir, boolean includeFile, boolean includeDirectory, int scanDepth, String... matchingPattern ) {        if( notExists( searchDir ) ) return new ArrayList<>();        Path rootDir = isFile( searchDir ) ? searchDir.getParent() : searchDir;        FileFinder finder = new FileFinder( includeFile, includeDirectory, matchingPattern );        scanDepth = ( scanDepth < 0 ) ? Integer.MAX_VALUE : ++scanDepth;        try {        	Files.walkFileTree( rootDir, EnumSet.noneOf( FileVisitOption.class ), scanDepth, finder );        } catch( IOException e ) {	        throw new UncheckedIOException( e );        }        return finder.getFindResult();    }    /**     * Check path exists     *     * @param path  file or directory path     * @return true if path exists     */    public static boolean exists( Path path ) {    	return path != null && Files.exists( path );    }    /**     * Check path exists     *     * @param path  file or directory path     * @return true if path exists     */    public static boolean exists( String path ) {        return exists( new File( path ) );    }    /**     * Check file exist     * @param file file to check     * @return true if file exists     */    public static boolean exists( File file ) {    	return file != null && file.exists();    }    public static boolean notExists( Path path ) {    	return path != null && Files.notExists( path );    }    public static boolean notExists( String path ) {    	return notExists( Paths.get( path ) );    }    public static boolean notExists( File file ) {    	return file != null && notExists( file.toPath() );    }    public static boolean isFile( Path path ) {    	return path != null && Files.isRegularFile( path );    }    public static boolean isFile( String path ) {        try {            return isFile( new File(path) );        } catch( InvalidPathException e ) {            return false;        }    }    public static boolean isFile( File file ) {    	return file != null && isFile( file.toPath() );    }    public static boolean isDirectory( Path path ) {    	return path != null && Files.isDirectory( path );    }    public static boolean isDirectory( String path ) {    	try {            return isDirectory( Paths.get(path) );        } catch( InvalidPathException e ) {            return false;        }    }    public static boolean isDirectory( File file ) {    	return file != null && isDirectory( file.toPath() );    }    /**     * Make directory     *     * @param directoryPath directory path     * @return created directory     * @throws UncheckedIOException  if an I/O error occurs     */    public static File makeDir( String directoryPath ) throws UncheckedIOException {    	if( directoryPath == null ) return null;    	return makeDir( Paths.get( directoryPath ) );    }    /**     * Make directory     *     * @param directory directory path     * @return created directory     * @throws UncheckedIOException  if an I/O error occurs     */    public static File makeDir( File directory ) throws UncheckedIOException {        if( directory == null ) return null;        return makeDir( directory.toPath() );    }    /**     * Make directory     *     * @param directory directory path     * @return created directory     * @throws UncheckedIOException  if an I/O error occurs     */    public static File makeDir( Path directory ) throws UncheckedIOException {    	if( directory == null ) return null;    	if( Files.exists(directory) ) return directory.toFile();    	try {    		return Files.createDirectories( directory ).toFile();    	} catch( IOException e ) {    		throw new UncheckedIOException( e );    	}    }    /**     * Make file (if directory path is not exists, create it additionally.)     *     * @param filePath file path     * @return created file     * @throws UncheckedIOException  if an I/O error occurs     */    public static File makeFile( String filePath ) throws UncheckedIOException {    	if( filePath == null ) return null;    	return makeFile( Paths.get(filePath) );    }    /**     * Make file (if directory path is not exists, create it additionally.)     *     * @param filePath file path     * @return created file     * @throws UncheckedIOException  if an I/O error occurs     */    public static File makeFile( Path filePath ) throws UncheckedIOException {    	if( filePath == null ) return null;    	if( Files.exists( filePath ) ) {    		return filePath.toFile();    	} else {    		makeDir( filePath.getParent().toString() );    	}    	try {    		return Files.createFile( filePath ).toFile();    	} catch( IOException e ) {    		throw new UncheckedIOException( e );    	}    }    /**     * Make file (if directory path is not exists, create it additionally.)     *     * @param file file to create     * @return created file     * @throws UncheckedIOException  if an I/O error occurs     */    public static File makeFile( File file ) throws UncheckedIOException {    	if( file == null ) return null;    	return makeFile( file.toPath() );    }    /**     * Move file or directory     *     * @param  source     file or directory path to move     * @param  target     file or directory path of target     * @param  overwrite  overwrite if the target file exists     * @throws UncheckedIOException if an I/O error occurs     */    public static void move( String source, String target, boolean overwrite ) throws UncheckedIOException {        Path sourcePath = Paths.get( source );        Path targetPath = Paths.get( target );        move( sourcePath, targetPath, overwrite );    }    /**     * Move file or directory     *     * @param  source     file or directory path to move     * @param  target     file or directory path of target     * @param  overwrite  overwrite if the target file exists     * @throws UncheckedIOException if an I/O error occurs     */    public static void move( Path source, Path target, boolean overwrite ) throws UncheckedIOException {        CopyOption[] option = overwrite                ? new CopyOption[] { StandardCopyOption.REPLACE_EXISTING }                : new CopyOption[] {};        try {            if( Files.isDirectory(source) ) {                Files.move( source, target, option );            } else {                if( Files.isDirectory(target) ) {                    Files.move( source, target.resolve( source.getFileName() ), option );                } else {                    Files.move( source, target, option );                }            }        } catch( IOException e ) {            throw new UncheckedIOException( e );        }    }    /**     * Copy file or directory     *     * @param  source     file or directory path to move     * @param  target     file or directory path of target     * @param  overwrite  overwrite if the target file exists     * @throws UncheckedIOException if an I/O error occurs     */    public static void copy( String source, String target, boolean overwrite ) throws UncheckedIOException {        Path sourcePath = Paths.get( source );        Path targetPath = Paths.get( target );        copy( sourcePath, targetPath, overwrite );    }    /**     * Copy file or directory     *     * @param  source     file or directory path to copy     * @param  target     file or directory path of target     * @param  overwrite  overwrite if the target file exists     * @throws UncheckedIOException if an I/O error occurs     */    public static void copy( Path source, Path target, boolean overwrite ) throws UncheckedIOException {        CopyOption[] option = overwrite                ? new CopyOption[] { StandardCopyOption.COPY_ATTRIBUTES, StandardCopyOption.REPLACE_EXISTING }                : new CopyOption[] { StandardCopyOption.COPY_ATTRIBUTES };        try {            if( Files.isDirectory(source) ) {                for( Path path : search( source, true, true, -1 ) ) {                    Path targetPath = target.resolve( source.relativize(path) );                    if( FileUtil.isDirectory( targetPath ) ) {                        makeDir( path );                        continue;                    }                    Files.copy( path, targetPath, option );                }            } else {                if( Files.isDirectory(target) ) {                    Files.copy( source, target.resolve( source.getFileName() ), option );                } else {                    Files.copy( source, target, option );                }            }        } catch( IOException e ) {            throw new UncheckedIOException( e );        }    }    /**     * Read serialized objects data stored in file     *     * @param filePath  path of file which store serialized objects data.     * @return object bean to serialize     * @throws ClassNotExistException   if object's class is not defined     * @throws UncheckedIOException     if an I/O error occurs     */    @SuppressWarnings( "unchecked" )    public static <T> T readObject( String filePath ) throws ClassNotExistException, UncheckedIOException {        try(                InputStream file   = new FileInputStream( filePath );                InputStream buffer = new GZIPInputStream( file );                ObjectInput input  = new ObjectInputStream( buffer ) ) {            return (T) input.readObject();        } catch( ClassNotFoundException e ) {            throw new ClassNotExistException( e );        } catch( IOException e ) {        	throw new UncheckedIOException( e );        }    }    /**     * Read serialized objects data stored in file     *     * @param file  file stored serialized objects data.     * @return object bean to serialize     * @throws ClassNotExistException   if object's class is not defined     * @throws UncheckedIOException     if an I/O error occurs     */    public static <T> T readObject( File file ) throws ClassNotExistException, UncheckedIOException {    	return readObject( file.getPath() );    }    /**     * remove extension from path     *     * @param filePath  file path (or file name)     * @return file path which has no extension.     */    public static String removeExtention( String filePath ) {        if( filePath == null ) return filePath;        int index = filePath.lastIndexOf( '.' );        if( index < 0 ) return filePath;        String ext = filePath.substring( index + 1 );        if( ext.contains( File.pathSeparator ) ) return filePath;        return filePath.substring( 0, index );    }    /**     * Read text from file     * @param filePath  file path     * @return text     * @throws UncheckedIOException if I/O error occurs     */    public static String readFrom( String filePath ) throws UncheckedIOException {    	return readFrom( filePath, "UTF-8" );    }    /**     * Read text from file     *     * @param filePath  file path     * @param charset   characterset (UTF-8, EUC-KR, ... )     * @return text     * @throws UncheckedIOException if I/O error occurs     */    public static String readFrom( String filePath, String charset ) throws UncheckedIOException {    	StringBuilder sb = new StringBuilder();    	readFrom( filePath, readLine -> {            sb.append( readLine ).append( '\n' );        }, charset );    	return sb.toString();    }    /**     * Read text from file     *     * @param file      file path     * @param charset   characterset (UTF-8, EUC-KR, ... )     * @return text     * @throws UncheckedIOException if I/O error occurs     */    public static String readFrom( File file, String charset ) throws UncheckedIOException {    	return readFrom( file.getPath(), charset );    }    /**     * Read text from file     *     * @param file file path     * @return text     * @throws UncheckedIOException if I/O error occurs     */    public static String readFrom( File file ) throws UncheckedIOException {    	return readFrom( file.getPath(), "UTF-8" );    }    /**     * Read text from file     *     * <pre>     *   StringBuilder sb = new StringBuilder();     *     *   readFrom( filePath, readLine -&gt; {     *     sb.append( readLine ).append( '\n' );     *   });     *     *   System.out.println( sb );     * </pre>     *     * @param filePath  file path     * @param worker    worker to treat line in text     * @throws UncheckedIOException if I/O error occurs     */    public static void readFrom( Path filePath, WorkerReadLine worker ) throws UncheckedIOException {        readFrom( filePath, worker, "UTF-8" );    }    /**     * Read text from file     *     * <pre>     *   StringBuilder sb = new StringBuilder();     *     *   readFrom( filePath, readLine -&gt; {     *     sb.append( readLine ).append( '\n' );     *   }, charset );     *     *   System.out.println( sb );     * </pre>     *     * @param filePath  file path     * @param worker    worker to treat line in text     * @param charset   characterset (UTF-8, EUC-KR, ... )     * @throws UncheckedIOException if I/O error occurs     */    public static void readFrom( Path filePath, WorkerReadLine worker, String charset ) throws UncheckedIOException {        readFrom( filePath.toString(), worker, charset );    }    public static void readFrom( File filePath, WorkerReadLine worker, String charset ) throws UncheckedIOException {    	readFrom( filePath.toString(), worker, charset );    }    public static void readFrom( File filePath, WorkerReadLine worker ) throws UncheckedIOException {    	readFrom( filePath.toString(), worker, UTF_8 );    }    public static void readFrom( String filePath, WorkerReadLine worker ) throws UncheckedIOException {        readFrom( filePath, worker, UTF_8 );    }    public static void readFrom( String filePath, WorkerReadLine worker, String charset ) throws UncheckedIOException {        try {            FileInputStream fis = new FileInputStream( filePath );            readFrom( fis, worker, charset );        } catch( FileNotFoundException e ) {            throw new UncheckedIOException( e );        }    }    public static void readFrom( InputStream inputStream, WorkerReadLine worker ) {        readFrom( inputStream, worker, UTF_8 );    }    public static void readFrom( InputStream inputStream, WorkerReadLine worker, String charset ) {        try(            BufferedReader br = new BufferedReader( new InputStreamReader(inputStream, charset) )        ) {            String line;            while( ( line = br.readLine() ) != null ) {                worker.execute( line );            }        } catch( IOException e ) {            throw new UncheckedIOException( e );        } finally {            try {                if( inputStream != null ) inputStream.close();            } catch( IOException e ) {}        }    }    public static void readResourceFrom( String filePath, WorkerReadLine worker ) {        readResourceFrom( filePath, worker, UTF_8 );    }    public static void readResourceFrom( String filePath, WorkerReadLine worker, String charset ) {        if( FileUtil.exists( filePath ) ) {            readFrom( filePath, worker, charset );        } else {            String resourcePath = Const.path.toResourceName( filePath );            InputStream inputStream = ClassUtil.getResourceAsStream( resourcePath );            if( inputStream != null ) {                readFrom( inputStream, worker, charset );            }        }    }    public static String readResourceFrom( String filePath ) {        return readResourceFrom( filePath, UTF_8 );    }    public static String readResourceFrom( String filePath, String charset ) {        StringBuilder sb = new StringBuilder();        readResourceFrom( filePath, readLine -> {            sb.append( readLine ).append( '\n' );        }, charset );        return sb.toString();    }    public static boolean isResourceExisted( String filePath ) {        if( FileUtil.exists( filePath ) ) {            return true;        } else {            String resourcePath = Const.path.toResourceName( filePath );            return ClassUtil.isResourceExisted( resourcePath );        }    }    public static InputStream getResourceAsStream( String filePath ) {        if( FileUtil.exists( filePath ) ) {            try {                return new FileInputStream( filePath );            } catch( FileNotFoundException e ) {                throw new UncheckedIOException( e );            }        } else {            String resourcePath = Const.path.toResourceName( filePath );            return ClassUtil.getResourceAsStream( resourcePath );        }    }    /**     * Write text to file     *     * <pre>     *  writeTo( filePath, writer -&gt; {     *    writer.write( text );     *  }, "EUC-KR" );     * </pre>     *     * @param filePath  file path to write text     * @param handler   handler to write line     * @param charset   encoding character set     * @throws UncheckedIOException     */    public static void writeTo( String filePath, WorkerWriteBuffer handler, String charset ) throws UncheckedIOException {        makeFile( filePath );        try(            FileOutputStream fos    = new FileOutputStream( filePath );            BufferedWriter   writer = new BufferedWriter( new OutputStreamWriter( fos, charset ) )        ) {            handler.execute( writer );        } catch( IOException e ) {            throw new UncheckedIOException(e);        }    }    /**     * Write text to file (encoding characterset is "UTF-8")     *     * <pre>     *  writeTo( filePath, writer -&gt; {     *    writer.write( text );     *  });     * </pre>     *     * @param filePath  file path to write text     * @param handler   handler to write line     * @throws UncheckedIOException     */    public static void writeTo( String filePath, WorkerWriteBuffer handler ) throws UncheckedIOException {        writeTo( filePath, handler, UTF_8 );    }    /**     * Write text to file     *     * @param filePath  file full path     * @param text      text to write     * @throws UncheckedIOException  if an I/O error occurs     */    public static void writeTo( String filePath, final String text ) throws UncheckedIOException {        writeTo( filePath, text, UTF_8 );    }    /**     * Write text to file     *     * @param filePath  file full path     * @param text      text to write     * @param charset   encoding character set     * @throws UncheckedIOException  if an I/O error occurs     */    public static void writeTo( String filePath, final String text, String charset ) throws UncheckedIOException {        writeTo( filePath, writer -> {            writer.write( text );        }, charset );    }    /**     * Write text to file     *     * @param file  file     * @param text  text to write     * @throws UncheckedIOException  if an I/O error occurs     */    public static void writeTo( File file, final String text ) throws UncheckedIOException {    	writeTo( file.getAbsolutePath(), text );    }    /**     * Write binary data to file     *     * @param file  file to write     * @param binary binary data to write     * @throws UncheckedIOException  if an I/O error occurs     */    public static void writeTo( File file, byte[] binary ) throws UncheckedIOException {    	makeFile( file );    	FileOutputStream stream = null;    	try {    		stream = new FileOutputStream( file );    	    stream.write( binary );    	} catch( IOException e ) {	        throw new UncheckedIOException(e);        } finally {    	    if( stream != null ) try { stream.close(); } catch( IOException e ) {}    	}    }    /**     * Write binary data to file     *     * @param path   file path to write     * @param binary binary data to write     * @throws UncheckedIOException  if an I/O error occurs     */    public static void writeTo( Path path, byte[] binary ) throws UncheckedIOException {        writeTo( path.toFile(), binary );    }    /**     * write bean to file     *     * @param filePath  full file path     * @param bean      bean to write     * @throws UncheckedIOException  file I/O exception     */    public static void writeObject( String filePath, Object bean ) throws UncheckedIOException {    	makeFile( filePath );        try(                OutputStream file   = new FileOutputStream( filePath );                OutputStream buffer = new GZIPOutputStream( file );                ObjectOutput output = new ObjectOutputStream( buffer )        ) {            output.writeObject( bean );            output.flush();            output.close();        } catch( IOException e ) {            throw new UncheckedIOException( e );        }    }    /**     * write bean to file     *     * @param file  file     * @param bean  bean to write     * @throws UncheckedIOException  if an I/O error occurs     */    public static void writeObject( File file, Object bean ) throws UncheckedIOException {        writeObject( file.getPath(), bean );    }    /**     * Write data as CSV file     *     * @param file      file to write     * @param data      data represents excel sheet     * @param delimiter delimiter to seperate data     * @param charset   character set     * @throws UncheckedIOException     */    public static void writeToCsv( String file, List data, String delimiter, String charset ) throws UncheckedIOException {        writeToCsv( file, new NList( data ), delimiter, charset );    }    /**     * Write data as CSV file     *     * @param file      file to write     * @param data      data represents excel sheet     * @param delimiter delimiter to seperate data     * @param charset   character set     * @throws UncheckedIOException     */    public static void writeToCsv( String file, NList data, String delimiter, String charset ) throws UncheckedIOException {    	writeTo( file, writer -> {            writer.write( StringUtil.join( data.getAliases(), delimiter ) );            writer.write( '\n' );            for( int row = 0, rowCnt = data.size(); row < rowCnt; row++ ) {                List<String> temp = new ArrayList<>();                for( int col = 0, colCnt = data.keySize(); col < colCnt; col++ ) {                    temp.add( data.getString( col, row ) );                }                writer.write( StringUtil.join( temp, delimiter ) );                writer.write( '\n' );            }        }, charset );    }    /**     * Convert relative path to absolute path     *     * <pre>     * FileUtil.toAbsolutePath( "/home/user/nayasis", "../test/abc" );     *     * → "/home/user/test/abc"     * </pre>     *     * @param basePath   bast path     * @param targetPath target path to convert     * @return absolute path     * @throws FileNotFoundException base path is not existed     */    public static String toAbsolutePath( String basePath, String targetPath ) throws FileNotFoundException {    	Path pathBase = getDirectory( Paths.get(basePath) );    	return nomalizeSeparator( pathBase.resolve( targetPath ).normalize().toString() );    }    /**     * Convert absolute path to relative path     *     * <pre>     * FileUtil.toRelativePath( "/home/user/nayasis", "/home/user/test/abc" );     *     * → "../test/abc"     * </pre>     *     * @param basePath   base path     * @param targetPath target path to convert     * @return relative path     * @throws FileNotFoundException    base path is not existed     * @throws IllegalArgumentException target path has no base path (for example, basePath is "c:" and targetPath is "d:")     */    public static String toRelativePath( String basePath, String targetPath ) throws FileNotFoundException {    	Path pathBase = getDirectory( Paths.get(basePath) );    	return nomalizeSeparator( pathBase.relativize( Paths.get( targetPath ) ).toString() );    }    /**     * Get working directory     *     * @param path File or Directory     * @return return parent directory if path is file, return itself it path is directory.     * @throws FileNotFoundException paht is not invalid     */    public static File getDirectory( String path ) throws FileNotFoundException {        return getDirectory( new File(path) );    }    /**     * Get working directory     *     * @param path File or Directory     * @return return parent directory if path is file, return itself it path is directory.     * @throws FileNotFoundException paht is not invalid     */    public static File getDirectory( File path ) throws FileNotFoundException {        return getDirectory( path.toPath() ).toFile();    }    /**     * Get working directory     *     * @param path File or Directory     * @return return parent directory if path is file, return itself it path is directory.     * @throws FileNotFoundException paht is not invalid     */    public static Path getDirectory( Path path ) throws FileNotFoundException {    	if( ! exists( path ) ) throw new FileNotFoundException( StringUtil.format( "path : {}", path ) );        return isDirectory(path) ? path : path.getParent();    }    /**     * Zip file or directory     *     * @param fileOrDirectoryToZip file or directory to zip     * @param targetFile archive file     * @param charset characterset (default : UTF-8)     */    public static void zip( File fileOrDirectoryToZip, File targetFile, Charset charset ) {        getZipFileHandler().zip( fileOrDirectoryToZip, targetFile, charset );    }    /**     * Zip file or directory     *     * @param fileOrDirectoryToZip file or directory to zip     * @param targetFile archive file     */    public static void zip( File fileOrDirectoryToZip, File targetFile ) {        zip( fileOrDirectoryToZip, targetFile, Charset.defaultCharset() );    }    /**     * Zip file or directory     *     * @param fileOrDirectoryToZip file or directory to zip     * @param targetFile archive file     * @param charset characterset (default : UTF-8)     */    public static void zip( Path fileOrDirectoryToZip, Path targetFile, Charset charset ) {        zip( fileOrDirectoryToZip.toFile(), targetFile.toFile(), charset );    }    /**     * Zip file or directory     *     * @param fileOrDirectoryToZip file or directory to zip     * @param targetFile archive file     */    public static void zip( Path fileOrDirectoryToZip, Path targetFile ) {        zip( fileOrDirectoryToZip.toFile(), targetFile.toFile() );    }    /**     * Unzip file or directory     *     * @param fileToUnzip file to unzip     * @param targetDirectory directory to unzip     * @param charset characterset (default : UTF-8)     */    public static void unzip( File fileToUnzip, File targetDirectory, Charset charset ) {        getZipFileHandler().unzip( fileToUnzip, targetDirectory, charset );    }    /**     * Unzip file or directory     *     * @param fileToUnzip file to unzip     * @param targetDirectory directory to unzip     */    public static void unzip( File fileToUnzip, File targetDirectory ) {        unzip( fileToUnzip, targetDirectory, Charset.defaultCharset() );    }    /**     * Unzip file or directory     *     * @param fileToUnzip file to unzip     * @param targetDirectory directory to unzip     * @param charset characterset (default : UTF-8)     */    public static void unzip( Path fileToUnzip, Path targetDirectory, Charset charset ) {        unzip( fileToUnzip.toFile(), targetDirectory.toFile(), charset );    }    /**     * Unzip file or directory     *     * @param fileToUnzip file to unzip     * @param targetDirectory directory to unzip     */    public static void unzip( Path fileToUnzip, Path targetDirectory ) {        unzip( fileToUnzip.toFile(), targetDirectory.toFile() );    }    private static ZipFileHandler getZipFileHandler() {        try {            return new ZipFileHandler();        } catch( Throwable e ) {            String errorMessage =                    "you must import [Apache Common Compress Library] to handle zip file.\n" +                            "\t- Maven dependency is like below.\n" +                            "\t\t<dependency>\n" +                            "\t\t  <groupId>org.apache.commons</groupId>\n" +                            "\t\t  <artifactId>commons-compress</artifactId>\n" +                            "\t\t  <version>1.8</version>\n" +                            "\t\t</dependency>\n";            throw new NoClassDefFoundError( errorMessage );        }    }    /**     * Resolve path with base path     *     * <pre>     *   FileUtil.getPath( "/root/bin", ".././temp" );     *     → "/root/temp"     *   FileUtil.getPath( "/root/bin", "/./temp" );     *     → "/root/bin/temp"     *   FileUtil.getPath( "/root/bin", "temp" );     *     → "/root/bin/temp     * </pre>     *     * @param basePath      base path     * @param resolvedPath  path to resolve with base path     * @return resolved path     */    public static String getPath( String basePath, String resolvedPath ) {        List<String> pathList = StringUtil.tokenize( nomalizeSeparator( basePath ), "/" );        List<String> children = StringUtil.tokenize( nomalizeSeparator( resolvedPath ), "/" );        pathList.addAll( children );        for( int i = 0, iCnt = pathList.size(); i < iCnt; i++ ) {            String path = pathList.get( i );            if( "".equals(path) || ".".equals(path) ) {                pathList.remove( i );                iCnt--;            } else if( "..".equals( path ) ) {                pathList.remove( i );                iCnt--;                if( i > 0 && pathList.size() > 1 ) {                    pathList.remove( i - 1 );                    iCnt--;                }            }        }        return StringUtil.join( pathList, "/" );    }}