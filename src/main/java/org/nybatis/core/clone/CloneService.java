package org.nybatis.core.clone;

import org.nybatis.core.exception.unchecked.ReflectiveException;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;

/**
 * @author nayasis@gmail.com
 * @since 2017-03-24
 */
public class CloneService {

    private boolean forceModification = false;

    private final ConcurrentHashMap<Class,List<Field>> cacheFields = new ConcurrentHashMap<>();

    public boolean isForceModification() {
        return forceModification;
    }

    public void setForceModification( boolean forceModification ) {
        this.forceModification = forceModification;
    }

    public void setField( Object bean, Field field, Object value ) {

        if( field == null ) return;
        setAccessible( field );

        if( isExclusive(field) ) return;

        try {
            if( Modifier.isStatic(field.getModifiers()) ){
                field.set( null, value );
            } else {
                field.set( bean, value );
            }
        } catch( IllegalAccessException e ) {
            throw new ReflectiveException( e.getMessage(), e );
        }

    }

    public <T> T getFieldValue( Object bean, Field field ) {

        if( field == null ) return null;
        setAccessible( field );

        Object val;
        try {
            if( Modifier.isStatic(field.getModifiers()) ){
                val = field.get( null );
            } else {
                val = field.get( bean );
            }
            return val == null ? null : (T) val;
        } catch( IllegalAccessException e ) {
            throw new ReflectiveException( e.getMessage(), e );
        }

    }

    private void setAccessible( Field field ) {
        if( ! field.isAccessible() ) {
            field.setAccessible( true );
        }
    }

    public  List<Field> getFields( Object object ) {
        if( object == null ) return new ArrayList<>();
        return getFields( object.getClass() );
    }

    public List<Field> getFields( Class klass ) {

        if( ! cacheFields.containsKey(klass) ) {

            List<Field> fields = new ArrayList<>();

            if( klass == null ) return fields;

            for( Field field : klass.getDeclaredFields() ) {
                if( field.isSynthetic() ) continue; // if field is generated by compiler, skip it.
                if( field.isEnumConstant() ) continue;
                fields.add( field );
            }

            Class<?> superClass = klass.getSuperclass();

            if( superClass != null && superClass != Object.class ) {
                fields.addAll( getFields( superClass ) );
            }

            cacheFields.putIfAbsent( klass, fields );

        }

        return cacheFields.get( klass );

    }

    private boolean isExclusive( Field field ) {
        if( field.isSynthetic() ) return true; // if field is generated by compiler, skip it.
        if( field.isEnumConstant() ) return true;
        if( ! forceModification ) {
            if( Modifier.isTransient( field.getModifiers() ) ) return true;
            if( Modifier.isFinal( field.getModifiers() )) return true;
        }
        return false;
    }

}
