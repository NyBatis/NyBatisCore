package org.nybatis.core.clone;

import org.nybatis.core.exception.unchecked.ReflectiveException;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;


/**
 * @author nayasis@gmail.com
 * @since 2017-03-24
 */
public class CoreReflector {

    private boolean forceModification = false;

    private final ConcurrentHashMap<Class,Set<Field>>  cacheField  = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<Class,Set<Method>> cacheMethod = new ConcurrentHashMap<>();

    public boolean isForceModification() {
        return forceModification;
    }

    public void setForceModification( boolean forceModification ) {
        this.forceModification = forceModification;
    }

    public void setField( Object bean, Field field, Object value ) {

        if( field == null ) return;
        setAccessible( field );

        if( isExclusive(field) ) return;

        try {
            if( Modifier.isStatic(field.getModifiers()) ){
                field.set( null, value );
            } else {
                field.set( bean, value );
            }
        } catch( IllegalAccessException e ) {
            throw new ReflectiveException( e.getMessage(), e );
        }

    }

    public <T> T getFieldValue( Object bean, Field field ) {

        if( field == null ) return null;
        setAccessible( field );

        Object val;
        try {
            if( Modifier.isStatic(field.getModifiers()) ){
                val = field.get( null );
            } else {
                val = field.get( bean );
            }
            return val == null ? null : (T) val;
        } catch( IllegalAccessException e ) {
            throw new ReflectiveException( e.getMessage(), e );
        }

    }

    private void setAccessible( Field field ) {
        if( ! field.isAccessible() ) {
            field.setAccessible( true );
        }
    }

    public  Set<Field> getFields( Object object ) {
        if( object == null ) return new LinkedHashSet<>();
        return getFields( object.getClass() );
    }

    public Set<Field> getFields( Class klass ) {

        if( ! cacheField.containsKey(klass) ) {

            Set<Field> fields = new LinkedHashSet<>();

            if( klass == null ) return fields;

            for( Field field : klass.getDeclaredFields() ) {
                if( field.isSynthetic() ) continue; // if field is generated by compiler, skip it.
                if( field.isEnumConstant() ) continue;
                fields.add( field );
            }

            Class<?> superClass = klass.getSuperclass();

            if( superClass != null && superClass != Object.class ) {
                fields.addAll( getFields( superClass ) );
            }

            cacheField.putIfAbsent( klass, fields );

        }

        return cacheField.get( klass );

    }

    private boolean isExclusive( Field field ) {
        if( field.isSynthetic() ) return true; // if field is generated by compiler, skip it.
        if( field.isEnumConstant() ) return true;
        if( ! isForceModification() ) {
            if( Modifier.isTransient(field.getModifiers()) ) return true;
            if( Modifier.isFinal(field.getModifiers()) ) return true;
        }
        return false;
    }

    public  Set<Method> getMethods( Object object ) {
        if( object == null ) return new LinkedHashSet<>();
        return getMethods( object.getClass() );
    }

    public Set<Method> getMethods( Class klass ) {

        if( ! cacheMethod.containsKey(klass) ) {

            Set<Method> methods = new LinkedHashSet<>();

            if( klass == null ) return methods;

            for( Method method : klass.getDeclaredMethods() ) {
                if( method.isSynthetic() ) continue; // if method is generated by compiler, skip it.
                if( Modifier.isInterface(method.getModifiers()) ) continue;
                if( Modifier.isAbstract(method.getModifiers()) ) continue;
                methods.add( method );
            }

            Class<?> superClass = klass.getSuperclass();

            if( superClass != null && superClass != Object.class ) {
                methods.addAll( getMethods( superClass ) );
            }

            cacheMethod.putIfAbsent( klass, methods );

        }

        return cacheMethod.get( klass );

    }

}
